; define function
(define defun (macro (name args body)
    `(define ,name (lambda ,args ,body))))

; define macro
(define defmac (macro (name args body)
    `(define ,name (macro ,args ,body))))

; shortcuts for common list accessors
(define rest cdr)
(define first car)

; shortcuts for car/cdr combos
(defun caar (x) (car (car x)))
(defun cadr (x) (car (cdr x)))
(defun cdar (x) (cdr (car x)))
(defun cddr (x) (cdr (cdr x)))
(defun caaar (x) (car (caar x)))
(defun caadr (x) (car (cadr x)))
(defun cadar (x) (car (cdar x)))
(defun caddr (x) (car (cddr x)))
(defun cdaar (x) (cdr (caar x)))
(defun cdadr (x) (cdr (cadr x)))
(defun cddar (x) (cdr (cdar x)))
(defun cdddr (x) (cdr (cddr x)))
(defun caaaar (x) (car (caaar x)))
(defun caaadr (x) (car (caadr x)))
(defun caadar (x) (car (cadar x)))
(defun caaddr (x) (car (caddr x)))
(defun cadaar (x) (car (cdaar x)))
(defun cadadr (x) (car (cdadr x)))
(defun caddar (x) (car (cddar x)))
(defun cadddr (x) (car (cdddr x)))
(defun cdaaar (x) (cdr (caaar x)))
(defun cdaadr (x) (cdr (caadr x)))
(defun cdadar (x) (cdr (cadar x)))
(defun cdaddr (x) (cdr (caddr x)))
(defun cddaar (x) (cdr (cdaar x)))
(defun cddadr (x) (cdr (cdadr x)))
(defun cdddar (x) (cdr (cddar x)))
(defun cddddr (x) (cdr (cdddr x)))

; if
(defmac if (test true-body false-body)
    `(cond (,test ,true-body)
           (#t ,false-body)))

; nil
(define nil '())

; types and helpful type checkers
(defun nil? (x) (is? x nil))
(defun symbol? (e) (= (type e) "symbol"))
(defun string? (e) (= (type e) "string"))
(defun integer? (e) (= (type e) "integer"))
(defun float? (e) (= (type e) "float"))
(defun complex? (e) (= (type e) "complex"))
(defun number? (e) (or (integer? e) (float? e) (complex? e)))
(defun cons? (e) (= (type e) "cons"))
(defun function? (e) (= (type e) "function"))
(defun macro? (e) (= (type e) "macro"))
(defun callable? (e) (or (function? e) (macro? e)))

; let
(defmac let (sym-vals body)
    `((lambda (^(map car sym-vals)) ,body) ^(map cadr sym-vals)))

; recursive let
(defmac letrec (sym-vals body)
    (if (nil? sym-vals)
        body
        `(let (,(first sym-vals)) (letrec ,(rest sym-vals) ,body))))

; not equal
(defun != (a b) (not (= a b)))

; an element is an atom if it's not a list
(defun atom? (e) (not (list? e)))

; return a list of the passed-in items
(defun list (items ...) items)

; return the length of a proper list
(defun length (list)
    (if (nil? list)
        0
        (+ 1 (length (cdr list)))))

; return the nth item in a list. if n is less than 0 or out of bounds, errors.
(defun nth (n list)
    (cond ((= n 0) (car list))
          ((> n 0) (nth (- n 1) (cdr list)))))

; reverse a list
(defun reverse (list)
    (reverse-aux list nil))

(defun reverse-aux (list accum)
    (if (nil? list)
        accum
        (reverse-aux (rest list) (cons (first list) accum))))

; map
(defun map (f list)
    (if (nil? list)
        nil
        (cons (f (first list)) (map f (rest list)))))

; filter
(defun filter (f list)
    (cond ((nil? list) nil)
          ((f (first list)) (cons (first list) (filter f (rest list))))
          (#t (filter f (rest list)))))

; reduce
(defun reduce (f initial list)
    (if (nil? list)
        initial
        (f (first list) (reduce f initial (rest list)))))
