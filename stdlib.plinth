; define function
(define defun (macro (name args body)
    `(define ,name (lambda ,args ,body))))

; define macro
(define defmac (macro (name args body)
    `(define ,name (macro ,args ,body))))

; shortcuts for car/cdr combos
(defun caar (x) (car (car x)))
(defun cadr (x) (car (cdr x)))
(defun cdar (x) (cdr (car x)))
(defun cddr (x) (cdr (cdr x)))
(defun caaar (x) (car (caar x)))
(defun caadr (x) (car (cadr x)))
(defun cadar (x) (car (cdar x)))
(defun caddr (x) (car (cddr x)))
(defun cdaar (x) (cdr (caar x)))
(defun cdadr (x) (cdr (cadr x)))
(defun cddar (x) (cdr (cdar x)))
(defun cdddr (x) (cdr (cddr x)))
(defun caaaar (x) (car (caaar x)))
(defun caaadr (x) (car (caadr x)))
(defun caadar (x) (car (cadar x)))
(defun caaddr (x) (car (caddr x)))
(defun cadaar (x) (car (cdaar x)))
(defun cadadr (x) (car (cdadr x)))
(defun caddar (x) (car (cddar x)))
(defun cadddr (x) (car (cdddr x)))
(defun cdaaar (x) (cdr (caaar x)))
(defun cdaadr (x) (cdr (caadr x)))
(defun cdadar (x) (cdr (cadar x)))
(defun cdaddr (x) (cdr (caddr x)))
(defun cddaar (x) (cdr (cdaar x)))
(defun cddadr (x) (cdr (cdadr x)))
(defun cdddar (x) (cdr (cddar x)))
(defun cddddr (x) (cdr (cdddr x)))

; if
(defmac if (test true-body false-body)
    `(cond (,test ,true-body)
           (#t ,false-body)))

; let
(defmac let (sym-vals body)
    `((lambda (^(map car sym-vals)) ,body) ^(map cadr sym-vals)))

; not equal
(defun != (a b) (not (= a b)))

; an element is an atom if it's not a list
(defun atom? (e) (not (list? e)))

; check for nil and define its constant
(define nil '())
(defun nil? (x) (is? x nil))

; return a list of the passed-in items
(defun list (items ...) items)

; return the length of a proper list
(defun length (list)
    (cond ((nil? list) 0)
          (#t (+ 1 (length (cdr list))))))

; return the nth item in a list. if n is less than 0 or out of bounds, errors.
(defun nth (n list)
    (cond ((= n 0) (car list))
          ((> n 0) (nth (- n 1) (cdr list)))))

; reverse a list
(defun reverse (list)
    (reverse-aux list nil))

(defun reverse-aux (list accum)
    (cond ((nil? list) accum)
          (#t (reverse-aux (rest list) (cons (first list) accum)))))

; shortcuts for common list accessors
(define rest cdr)
(define first car)

; map
(defun map (f list)
    (cond ((nil? list) nil)
          (#t (cons (f (first list)) (map f (rest list))))))

; filter
(defun filter (f list)
    (cond ((nil? list) nil)
          ((f (first list)) (cons (first list) (filter f (rest list))))
          (#t (filter f (rest list)))))

; reduce
(defun reduce (f initial list)
    (cond ((nil? list) initial)
          (#t (f (first list) (reduce f initial (rest list))))))
